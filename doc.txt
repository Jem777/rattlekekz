METHODEN vom kekprotocol.py


für den controller

können gerufen werden (Argumente in klammern)

startConnection(server,port)
sendHandshake(clientident,verInt,netVer)
sendDebugInfo(client,ver,os,java)
getRooms()
sendLogin(nick,pwhash,room)
registerNick(nick,pwhash,email)
changePassword(pwhash,pwhashnew)
updateProfile(name,ort,homepage,hobbies,pwhash)
sendIdentify(pwhash)    			pwhash=md5(sha1(pw))
startPing()
sendPing()
sendMsg(channel,msg)
sendSlashCommand(command,channel,msg) wenn eine msg mit / anfängt, wird sie automatisch hiermit bearbeitet
sendPrivMsg(nick,msg)
sendCPMsg(user,msg)
sendCPAnswer(user,msg)
quitConnection()

sollten in den controller implementiert sein:


gotConnection()
receivedHandshake()
receivedRooms(rooms) 				rooms=[{"users":int, "max":int, "name":str},{nextRoom}]
successLogin(nick,status,room) 			nick=str, status=int, room=str
successRegister()
successNewPassword()
receivedProfile(name,ort,homepage,hobbies,signature)
successNewProfile()
securityCheck(infotext) 			
receivedPing(deltaPing) 			deltaPing=int in ms
receivedMsg(nick,channel,msg) 			channel kann auch self.Nickname sein, bei privaten unterhaltungen
receivedRoomMsg(channel,msg)			globale nachrichten im channel zB bei /me
privMsg(nick,msg) 				eigene nachricht ist angekommen, erst dann darf sie angezeigt werden
botMsg(bot,msg)
receivedRoomlist(rooms) 			rooms=[[roomname, user, maxuser, roomstate, sysroom],[nextRoom...]]
receivedUserlist(room,users)			room=str, users=[[username,away=bool,state=str],[nextUser,..]]
joinUser(room,nick,state,joinmsg)		all str
quitUser(room,nick,partmsg)			all str
changedUserdata(room,nick,away,state)		away=bool, everything else str
meJoin(room,background)				room=str, background=bool
mePart(room)
meGo(oldroom,newroom)
newTopic(room,topic)
loggedOut()
receivedInformation(info)
receivedCPMsg(user,cpmsg)
receivedCPAnswer(user,cpanswer)
gotException(msg)






Anhang:

Room:
Roomstatus 	Erklärung
x 	normal
o 	OP-Room
h 	versteckter Raum

Sysroom 	Erklärung
x 	normaler Systemraum
t 	temporärer Raum 

User:
Status	Bedeutung	normale Farbe
x	normal		schwarz
s 	special 	grün
c 	roomop		blau
o 	chatop		orange
a 	admin/sysadmin	rot 

Join Msg	Bedeutung
0 	Betritt den Raum (/join oder /go)
1 	Betritt den Chat (Login)
2 	Betritt den Raum durch Invite (/goinvite)

Part Msg 	 Bedeutung
0 	verlässt den Raum (PART)
1 	regulärer Logout (900)
2 	Verbindung verloren
3 	GHOST-Kick
4 	Ping Timeout
5 	Kick






------------------
||    VIEW      ||
------------------

KECKz ist nach MVC aufgebaut, daher kann man das View relativ einfach durch ein völlig anderes ersetzen.
Der Controller bearbeitet die vom Model eingehenden Daten soweit, dass sich die Arbeit des Views darauf
beschränkt, die Daten in das Gui-spezifische Format unzuwandeln und darzustellen. Dies macht es unglaublich
einfach ein View für KECKz zu schreiben.

Wichtige Voraussetzungen:
KECKz benutzt twisted als Netzwerkbibliothek, daher ist es erforderlich für Guis, das twisted einen reactor
für sie bereitstellt, siehe http://twistedmatrix.com/projects/core/documentation/howto/choosing-reactor.html
bei Textinterfaces ist es unerlässlich, dass der Input nonblocking ist, sonst müsste man ihn in einem thread
laufen lassen und threads sind moppelkotze. Für die die es trotzdem probieren wollen bietet twisted auch
threads an, siehe: http://twistedmatrix.com/projects/core/documentation/howto/threading.html

Die Klasse View:
Wenn man das Programm mit der keckz.py starten will muss die Datei, ich empfehle sie guiView.py (und statt
gui dann qt, gtk etc einzusetzen) oder so zu nennen, eine Klasse View besitzen. An diese Klasse werden dann
alle methoden gesendet. Damit man sich am Anfang nicht mit zu vielen fehlenden Methoden herumschlagen muss,
ist es praktisch so zu beginnen:


from twisted.internet import reactor   #jedes View muss sich den reactor selber importieren

class View:
    def unknownMethod(self,name):
        print str(name)

    def __getattr__(self, name):       #wird gerufen, wenn eine methode oder attribut nicht gefunden wird
        return self.unknownMethod(name)

if __name__=="__main__":
    server="kekz.net"
    import controllerKeckz
    controllerKeckz.Kekzcontroller(View).startConnection(server,23002)

das ist natürlich nicht genug, um einen richtiges View zu schreiben, daher kommt jetzt eine Auflistung von
allen Methoden, die immplementiert werden können und allen Methoden des Controllers, die das View rufen kann:


class View:
    def __init__(self,controller):
        self.name,self.version="qtKECKz","0.1"
        self.kekzControl=controller

    def receivedPreLoginData(self,rooms,array):
        pass

    def successLogin(self,nick,status,room):
        pass

    def successRegister(self):
        pass

    def successNewPassword(self):
        pass

    def receivedProfile(self,name,ort,homepage,hobbies,signature):
        pass

    def successNewProfile(self):
        pass

    def securityCheck(self, infotext):
        pass

    def receivedPing(self,deltaPing):
        pass

    def printMsg(self,nick,msg,channel,status):
        pass

    def gotException(self, message):
        pass

    def listUser(self,room,users):
        pass

    def meJoin(self,room,background):
        pass

    def mePart(self,room):
        pass

    def meGo(self,oldroom,newroom):
        pass

    def newTopic(self,room,topic):
        pass

    def loggedOut(self):
        pass

    def receivedInformation(self,info):
        pass

    def unknownMethod(self,name):
        pass

    def __getattr__(self, name):
        return self.unknownMethod(name)


if __name__=="__main__":
    server="kekz.net"
    import controllerKeckz
    controllerKeckz.Kekzcontroller(View).startConnection(server,23002)



Methoden des Controllers, die vom View aus gerufen werden können:
!!!das View sendet alle Passwörter im Klartext!!!

sendLogin(nick, passwd, rooms)

registerNick(nick,passwd,email)

changePassword(passwd,passwdnew)

updateProfile(name,ort,homepage,hobbies,signature,passwd)
#  signature ist der Freitext der im Whois auftaucht

sendIdentify(passwd)
#  muss als Antwort von securityCheck gesendet werden

sendMsg(channel, msg)
#  Diese Methode beinhaltet alle Arten von Msg: wenn room mit # anfängt,
#  ist es eine private Nachricht, mit wenn Msg mit / beginnt ein Slashcommando

sendJoin(room)
# nur wenn man nicht mit /j joinen will; zB für einen join-Dialog


Anhang:
Msgstatus       Erklärung
0       normale Msg
1       globale Room-msg
2       private Msg
3       eigene private Msg
4       Msg vom Bot (im aktuellen Raum anzeigen)
5       quit,part,etc Msg

